{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/codekata/2022-09-23-code-kata-codility-lesson2-oddoccurrencesinarray/","result":{"data":{"site":{"siteMetadata":{"title":"SeungHyun's Library"}},"markdownRemark":{"id":"ab240bb5-a49c-53db-ac27-c1094930ef87","excerpt":"https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/ 배열 A에는 같은 값을 가지는 숫자들이 pair된 상태, 즉 짝수개 존재한다. 하지만 그중 하나의 아이템은 pair…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 136.0759493670886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAIAAADzvTiPAAAACXBIWXMAAAsTAAALEwEAmpwYAAACmklEQVQ4y5WU65KjIBCFff8nnCQDatSIXBoQvAfdkk4yM5nspvb7gUDRaTh90knbtvROmqbnoqCUEkLSNM3ynBCSZVmapmVZ4gFKaZZllNK+7xNjDCGkLMs8UpZlURTFucjznFLKGMMJjucIIeRyuWzblgzDAABcCNDaWqu1NsZIKcdx3N6RhBAwwHtvjLHWOufayLzM1+t127Z1XXH8zh68rmvDG2PMMAxCCKWUc84YU9e17/w8z//KvK6rlNJ7P01TuIbtf0jw07atEEJKCQBKKSGF1hoAtNZKKQDA+78OvlwuH4eP4/GYpikh5HA4YG3yPD+dToSSEMJfgxljx9ORUpLH2hJCbrUpzlhYKeXv9yfXiHdOKWWi1MYYFHxX3t+UB4AXwW3bMsaklJzzt7V9LhVuuQhme6nNa7W996ittVZKZa0FACEE6iylVEo1vFF7EZQxBjeNMQCQgIbT6ZRlWZ7nn5+fhBBK6eFwQIdaa/u+93e6rsMRScZxxN8DABNxzunIsizvvY1hbdvi5Z1zePlxHB/e/s3d283u7WkapRAAsGc2hjHWdd00Te+93bbtMAzXZQlrwFQvLfUc3HWdiEgphRCc8/gKy2rGGNt9Hjc553V98d7/CHbONU0jhKiqinOOc611PC/wT4qzvu+frpMsyzIMg9Yaw5qmUWqv7SOn1pox1jTNC3viR0pZRqqqwkbFalYWZZqmdV3H7pZxzlHkH4Jt2yaEIIR8RLIs8971w+4Na+3DFcaYJ+feMgNAwxi+mXPOGNPm1gbQjygkFvUreBxHbCBINK3S0bry3luwnz7OKKXQf7vaRVFw3pRVpZRalmWe5yUSJ7cFbk5IXKzrmoTotbCGEMeH+8LXJNxX4bs9Qwh/AFzFBD+t8RXcAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image\"\n        title=\"image\"\n        src=\"/static/41077287b9d30b08d54855024b3903a8/f058b/asset-1.png\"\n        srcset=\"/static/41077287b9d30b08d54855024b3903a8/c26ae/asset-1.png 158w,\n/static/41077287b9d30b08d54855024b3903a8/6bdcf/asset-1.png 315w,\n/static/41077287b9d30b08d54855024b3903a8/f058b/asset-1.png 630w,\n/static/41077287b9d30b08d54855024b3903a8/5a190/asset-1.png 800w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<a href=\"https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/\">https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/</a></p>\n<p>배열 A에는 같은 값을 가지는 숫자들이 pair된 상태, 즉 짝수개 존재한다. 하지만 그중 하나의 아이템은 pair되지 않은 값을 가지고 있다. 그 아이템의 값을 찾는 문제다.</p>\n<hr>\n<h3>풀이</h3>\n<p><a href=\"https://app.codility.com/demo/results/training2V8WF7-FPQ/\">https://app.codility.com/demo/results/training2V8WF7-FPQ/</a></p>\n<p>오름차순으로 정렬 후, loop를 2 step씩 돌면서 현재 아이템과 다음 아이템이 같은지 비교한다.</p>\n<ol>\n<li>배열의 길이가 1일때</li>\n<li>A[i] 와 A[i+1]이 다를때 => pair 된 상태가 아닌 상태의 값을 찾음</li>\n<li>i+1이 배열의 길이일때 => 배열 길이가 홀수라는 뜻이고, 2번을 모두 통과 한 상태이므로 마지막 남은 아이템이 Odd상태임</li>\n</ol>\n<hr>\n<h3>오답</h3>\n<h4>out of range</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def solution(A):\n    if len(A) == 1: \n        return A[0]\n\n    A = sorted(A)\n\n    for i in range(0, len(A), 2):\n        if A[i] != A[i + 1] or (i + 1) == len(A):\n            return A[i]</code></pre></div>\n<p><a href=\"https://app.codility.com/demo/results/trainingAN7S3E-H4R/\">https://app.codility.com/demo/results/trainingAN7S3E-H4R/</a></p>\n<p><code class=\"language-text\">A[i] != A[i+1]</code> 조건이 먼저 오게되어 out of range 오류가 발생했다.</p>\n<h4>효율성 실패</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def solution(A):\n    if len(A) == 1:\n        return A[0]\n    \n    stack = list(set(A))\n\n    for i in range(len(stack)):\n        if A.count(stack[i]) % 2 == 1:\n            return stack[i]</code></pre></div>\n<p><a href=\"https://app.codility.com/demo/results/trainingMC6B2P-59G/\">https://app.codility.com/demo/results/trainingMC6B2P-59G/</a></p>\n<p>Set을 통해 중복 값을 가지는 아이템을 제거한 배열 stack을 만들고 루프를 돌린다. stack[i] 값이 배열 A에 짝수개 존재하는지 카운팅하고 홀수면 그 값을 반환한다.</p>\n<p>O(N²) 시간복잡도를 가지는 알고리즘이다. 가급적 중첩 루프를 사용하는 방식은 하지 않는게 좋을것같다.</p>\n<hr>\n<h3>리뷰</h3>\n<p>좀 더 꼼꼼히 로직을 생각하고 확인하며, 시간복잡도를 생각하며 구현하자</p>","frontmatter":{"title":"[Code Kata] 코딜리티 Codility Lesson2 — OddOccurrencesInArray","date":"2022년 09월 23일","description":"https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/","category":null}},"previous":{"fields":{"slug":"/codekata/2022-09-17-code-kata-codility-lesson-2-cyclicrotation/"},"frontmatter":{"title":"[Code Kata] 코딜리티 Codility Lesson 2 — CyclicRotation"}},"next":{"fields":{"slug":"/codekata/2022-09-23-code-kata-codility-lesson3-frogjmp/"},"frontmatter":{"title":"[Code Kata] 코딜리티 Codility Lesson3 — FrogJmp"}}},"pageContext":{"id":"ab240bb5-a49c-53db-ac27-c1094930ef87","previousPostId":"aa7cddfa-63bb-5d7b-9c9b-a33e69ddb238","nextPostId":"72d51dbd-cced-56c7-8290-76dbe2674a8e"}},"staticQueryHashes":["2355076697","2841359383"]}